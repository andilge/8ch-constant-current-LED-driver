---
#########################################
# 8 channel led driver constant current #
#########################################

# code prepared for board v0.996, 2022-02-03

# esp board model:  MH-ET LIVE ESP32 MiniKit

# Pinout reference
# ================
# # --------------------------------------------
# | GPIO | Board | Usage                       |
# |------|-------|-----------------------------|
# | 02   | ~     | blue LED on module          |
# |------|-------|-----------------------------|
# | 04   | U701  | dallas temp. sensor         |
# |------|-------|-----------------------------|
# | 05   | J301  | momentary switch            |
# |------|-------|-----------------------------|
# | 13   | J501	 | data out for adressable LED |
# |------|-------|-----------------------------|
# | 16   | LED1	 | LED1 dimming (pwm)          |
# |------|-------|-----------------------------|
# | 17   | LED2	 | LED2 dimming (pwm)          |
# |------|-------|-----------------------------|
# | 18   | LED3	 | LED3 dimming (pwm)          |
# |------|-------|-----------------------------|
# | 19   | LED4	 | LED4 dimming (pwm)          |
# |------|-------|-----------------------------|
# | 21   | LED5  | LED5 dimming (pwm)          |
# |------|-------|-----------------------------|
# | 22   | LED6	 | LED6 dimming (pwm)          |
# |------|-------|-----------------------------|
# | 23   | LED7  | LED7 dimming (pwm)          |
# |------|-------|-----------------------------|
# | 25   | LED8  | LED8 dimming (pwm)          |
# |------|-------|-----------------------------|
# | 26   | J301  | rotary encoder pin A        |
# |------|-------|-----------------------------|
# | 27   | J301  | rotary encoder pin B        |
# |------|-------|-----------------------------|
# | 32   | J401  | motion sensor (pir)         |
# |------|-------|-----------------------------|
# | 33   | J501  | free to use GPIO            |
# ----------------------------------------------

##### basic configs #####

# set up variables
substitutions:
  my_name: 'Downlight'
  my_project_name: "andilge.cc-leds"
  my_project_version: '0.996'
  my_device: 'cc-leds'
  my_reboot_timeout: '30min'
  my_pwm_frequency: '19531Hz'
  my_default_transition: '2.5s'
  my_gamma_correct: '2.4'
  my_latitude: '!secret latitude'
  my_longitude: '!secret longitude'
  my_static_ip: 192.168.244.249

# define core configs
esphome:
  name: ${my_device}
  comment: ${my_name}
  platform: ESP32
  board: mhetesp32minikit
  project:
    name: "${my_project_name}"
    version: "${my_project_version}"


# import basic settings
<<: !include common/wifi.yaml
<<: !include common/api.yaml
<<: !include common/ota.yaml
<<: !include common/time.yaml
<<: !include common/logger.yaml
<<: !include common/web_server.yaml


##### start specific configs #####

script:
  # this shows effect on the ring around the encoder and restarts every time the momentary switch is pressed
  - id: switch_press_visualization
    mode: restart
    then:
      # fade out in 50ms
      - lambda: |-
          auto call = id(encoder_light_ring).turn_on ();
          call.set_transition_length (50);
          call.set_rgb(0.0, 0.01, 0.0);
          call.perform ();
      - delay : 50ms

      # fade in full green in 100ms and stay there 50ms
      - lambda: |-
          auto call = id(encoder_light_ring).make_call ();
          call.set_transition_length (100);
          call.set_rgb(0.0, 1.0, 0.0);
          call.perform ();
      - delay : 150ms

      # fade out in 100ms
      - lambda: |-
          auto call = id(encoder_light_ring).make_call ();
          call.set_transition_length (100);
          call.set_rgb(0.0, 0.01, 0.0);
          call.perform ();
      - delay : 100ms

      # transitate to default effect in 50ms
      - lambda: |-
          auto call = id(encoder_light_ring).make_call ();
            call.set_transition_length (50);
            call.set_effect("Brighness indicator");
            call.perform();
      - delay : 50ms

  # this shows effect on all 8 lights like a night light, fade in to bright, then after delay fall back to dimm light
  - id: motion_light_sequence
    mode: restart
    # fade in all downlights to 66% in 10sec
    then:
      - lambda: |-
          auto call = id(cc_led_01).turn_on ();
          call.set_transition_length (10000);
          call.set_brightness (0.66);
          call.perform ();

      - lambda: |-
          auto call = id(cc_led_02).turn_on ();
          call.set_transition_length (10000);
          call.set_brightness (0.66);
          call.perform ();

      - lambda: |-
          auto call = id(cc_led_03).turn_on ();
          call.set_transition_length (10000);
          call.set_brightness (0.66);
          call.perform ();

      - lambda: |-
          auto call = id(cc_led_04).turn_on ();
          call.set_transition_length (10000);
          call.set_brightness (0.66);
          call.perform ();

      - lambda: |-
          auto call = id(cc_led_05).turn_on ();
          call.set_transition_length (10000);
          call.set_brightness (0.66);
          call.perform ();

      - lambda: |-
          auto call = id(cc_led_06).turn_on ();
          call.set_transition_length (10000);
          call.set_brightness (0.66);
          call.perform ();

      - lambda: |-
          auto call = id(cc_led_07).turn_on ();
          call.set_transition_length (10000);
          call.set_brightness (0.66);
          call.perform ();

      - lambda: |-
          auto call = id(cc_led_08).turn_on ();
          call.set_transition_length (10000);
          call.set_brightness (0.66);
          call.perform ();

      # stay at this level for some time
      - delay: 150sec

      # fade out all downlights to 10% brightness in 3min
      - lambda: |-
          auto call = id(cc_led_01).make_call ();
          call.set_transition_length (30000);
          call.set_brightness (0.1);
          call.perform ();
      - lambda: |-
          auto call = id(cc_led_02).make_call ();
          call.set_transition_length (30000);
          call.set_brightness (0.1);
          call.perform ();
      - lambda: |-
          auto call = id(cc_led_03).make_call ();
          call.set_transition_length (30000);
          call.set_brightness (0.1);
          call.perform ();
      - lambda: |-
          auto call = id(cc_led_04).make_call ();
          call.set_transition_length (30000);
          call.set_brightness (0.1);
          call.perform ();
      - lambda: |-
          auto call = id(cc_led_05).make_call ();
          call.set_transition_length (30000);
          call.set_brightness (0.1);
          call.perform ();
      - lambda: |-
          auto call = id(cc_led_06).make_call ();
          call.set_transition_length (30000);
          call.set_brightness (0.1);
          call.perform ();
      - lambda: |-
          auto call = id(cc_led_07).make_call ();
          call.set_transition_length (30000);
          call.set_brightness (0.1);
          call.perform ();
      - lambda: |-
          auto call = id(cc_led_08).make_call ();
          call.set_transition_length (30000);
          call.set_brightness (0.1);
          call.perform ();

output:
    # measure amps and set max_power value to meet your light's characteristics !
  - platform: ledc
    pin: GPIO16
    frequency: ${my_pwm_frequency}
    id: pwm_out_01
    max_power: '75%' # lowering power to protect newly connected led lights

  - platform: ledc
    pin: GPIO17
    frequency: ${my_pwm_frequency}
    id: pwm_out_02
    max_power: '75%' # lowering power to protect newly connected led lights

  - platform: ledc
    pin: GPIO18
    frequency: ${my_pwm_frequency}
    id: pwm_out_03
    max_power: '75%' # lowering power to protect newly connected led lights

  - platform: ledc
    pin: GPIO19
    frequency: ${my_pwm_frequency}
    id: pwm_out_04
    max_power: '75%' # lowering power to protect newly connected led lights

  - platform: ledc
    pin: GPIO21
    frequency: ${my_pwm_frequency}
    id: pwm_out_05
    max_power: '75%'  # lowering power to protect newly connected led lights

  - platform: ledc
    pin: GPIO22
    frequency: ${my_pwm_frequency}
    id: pwm_out_06
    max_power: '75%' # lowering power to protect newly connected led lights

  - platform: ledc
    pin: GPIO23
    frequency: ${my_pwm_frequency}
    id: pwm_out_07
    max_power: '75%' # lowering power to protect newly connected led lights

  - platform: ledc
    pin: GPIO25
    frequency: ${my_pwm_frequency}
    id: pwm_out_08
    max_power: '75%' # lowering power to protect newly connected led lights

light:
  - platform: monochromatic
    id: cc_led_01
    name: '${my_name} 1'
    default_transition_length: ${my_default_transition}
    output: pwm_out_01
    gamma_correct: ${my_gamma_correct}
    on_turn_off:
      - light.addressable_set:
          id: encoder_light_ring
          range_from: 0
          range_to: 9
          red: 0%
          green: 0%
          blue: 0%

    on_turn_on:
      - light.addressable_set:
          id: encoder_light_ring
          range_from: 0
          range_to: !lambda |-
            return( ( ( id(cc_led_01).remote_values.get_brightness()) + (id(cc_led_01).remote_values.get_brightness()) + (id(cc_led_01).remote_values.get_brightness()) + (id(cc_led_01).remote_values.get_brightness()) + (id(cc_led_01).remote_values.get_brightness()) + (id(cc_led_01).remote_values.get_brightness()) + (id(cc_led_01).remote_values.get_brightness()) + (id(cc_led_01).remote_values.get_brightness() ) ) / 8 * 10 - 1 );
          red: 100%
          green: 50%
          blue: 0%

    on_state:
      - if:
          condition:
            light.is_on: cc_led_01
          then:
            - light.addressable_set:
                id: encoder_light_ring
                range_from: 0
                range_to: !lambda |-
                    return( ( ( id(cc_led_01).remote_values.get_brightness()) + (id(cc_led_01).remote_values.get_brightness()) + (id(cc_led_01).remote_values.get_brightness()) + (id(cc_led_01).remote_values.get_brightness()) + (id(cc_led_01).remote_values.get_brightness()) + (id(cc_led_01).remote_values.get_brightness()) + (id(cc_led_01).remote_values.get_brightness()) + (id(cc_led_01).remote_values.get_brightness() ) ) / 8 * 10 - 1 );
                red: 100%
                green: 50%
                blue: 0%

          else:
            - light.addressable_set:
                id: encoder_light_ring
                range_from: 0
                range_to: 9
                red: 0%
                green: 0%
                blue: 0%

  - platform: monochromatic
    id: cc_led_02
    name: '${my_name} 2'
    default_transition_length: ${my_default_transition}
    output: pwm_out_02
    gamma_correct: ${my_gamma_correct}

    on_turn_off:
      - light.addressable_set:
          id: encoder_light_ring
          range_from: 0
          range_to: 9
          red: 0%
          green: 0%
          blue: 0%

    on_turn_on:
      - light.addressable_set:
          id: encoder_light_ring
          range_from: 0
          range_to: !lambda |-
            return( ( ( id(cc_led_01).remote_values.get_brightness()) + (id(cc_led_01).remote_values.get_brightness()) + (id(cc_led_01).remote_values.get_brightness()) + (id(cc_led_01).remote_values.get_brightness()) + (id(cc_led_01).remote_values.get_brightness()) + (id(cc_led_01).remote_values.get_brightness()) + (id(cc_led_01).remote_values.get_brightness()) + (id(cc_led_01).remote_values.get_brightness() ) ) / 8 * 10 - 1 );
          red: 100%
          green: 50%
          blue: 0%

    on_state:
      - if:
          condition:
            light.is_on: cc_led_02
          then:
            - light.addressable_set:
                id: encoder_light_ring
                range_from: 0
                range_to: !lambda |-
                    return( ( ( id(cc_led_01).remote_values.get_brightness()) + (id(cc_led_01).remote_values.get_brightness()) + (id(cc_led_01).remote_values.get_brightness()) + (id(cc_led_01).remote_values.get_brightness()) + (id(cc_led_01).remote_values.get_brightness()) + (id(cc_led_01).remote_values.get_brightness()) + (id(cc_led_01).remote_values.get_brightness()) + (id(cc_led_01).remote_values.get_brightness() ) ) / 8 * 10 - 1 );
                red: 100%
                green: 50%
                blue: 0%

          else:
            - light.addressable_set:
                id: encoder_light_ring
                range_from: 0
                range_to: 9
                red: 0%
                green: 0%
                blue: 0%

  - platform: monochromatic
    id: cc_led_03
    name: '${my_name} 3'
    default_transition_length: ${my_default_transition}
    output: pwm_out_03
    gamma_correct: ${my_gamma_correct}

    on_turn_off:
      - light.addressable_set:
          id: encoder_light_ring
          range_from: 0
          range_to: 9
          red: 0%
          green: 0%
          blue: 0%

    on_turn_on:
      - light.addressable_set:
          id: encoder_light_ring
          range_from: 0
          range_to: !lambda |-
            return( ( ( id(cc_led_01).remote_values.get_brightness()) + (id(cc_led_01).remote_values.get_brightness()) + (id(cc_led_01).remote_values.get_brightness()) + (id(cc_led_01).remote_values.get_brightness()) + (id(cc_led_01).remote_values.get_brightness()) + (id(cc_led_01).remote_values.get_brightness()) + (id(cc_led_01).remote_values.get_brightness()) + (id(cc_led_01).remote_values.get_brightness() ) ) / 8 * 10 - 1 );
          red: 100%
          green: 50%
          blue: 0%

    on_state:
      - if:
          condition:
            light.is_on: cc_led_03
          then:
            - light.addressable_set:
                id: encoder_light_ring
                range_from: 0
                range_to: !lambda |-
                    return( ( ( id(cc_led_01).remote_values.get_brightness()) + (id(cc_led_01).remote_values.get_brightness()) + (id(cc_led_01).remote_values.get_brightness()) + (id(cc_led_01).remote_values.get_brightness()) + (id(cc_led_01).remote_values.get_brightness()) + (id(cc_led_01).remote_values.get_brightness()) + (id(cc_led_01).remote_values.get_brightness()) + (id(cc_led_01).remote_values.get_brightness() ) ) / 8 * 10 - 1 );
                red: 100%
                green: 50%
                blue: 0%

          else:
            - light.addressable_set:
                id: encoder_light_ring
                range_from: 0
                range_to: 9
                red: 0%
                green: 0%
                blue: 0%

  - platform: monochromatic
    id: cc_led_04
    name: '${my_name} 4'
    default_transition_length: ${my_default_transition}
    output: pwm_out_04
    gamma_correct: ${my_gamma_correct}

    on_turn_off:
      - light.addressable_set:
          id: encoder_light_ring
          range_from: 0
          range_to: 9
          red: 0%
          green: 0%
          blue: 0%

    on_turn_on:
      - light.addressable_set:
          id: encoder_light_ring
          range_from: 0
          range_to: !lambda |-
            return( ( ( id(cc_led_01).remote_values.get_brightness()) + (id(cc_led_01).remote_values.get_brightness()) + (id(cc_led_01).remote_values.get_brightness()) + (id(cc_led_01).remote_values.get_brightness()) + (id(cc_led_01).remote_values.get_brightness()) + (id(cc_led_01).remote_values.get_brightness()) + (id(cc_led_01).remote_values.get_brightness()) + (id(cc_led_01).remote_values.get_brightness() ) ) / 8 * 10 - 1 );
          red: 100%
          green: 50%
          blue: 0%

    on_state:
      - if:
          condition:
            light.is_on: cc_led_04
          then:
            - light.addressable_set:
                id: encoder_light_ring
                range_from: 0
                range_to: !lambda |-
                    return( ( ( id(cc_led_01).remote_values.get_brightness()) + (id(cc_led_01).remote_values.get_brightness()) + (id(cc_led_01).remote_values.get_brightness()) + (id(cc_led_01).remote_values.get_brightness()) + (id(cc_led_01).remote_values.get_brightness()) + (id(cc_led_01).remote_values.get_brightness()) + (id(cc_led_01).remote_values.get_brightness()) + (id(cc_led_01).remote_values.get_brightness() ) ) / 8 * 10 - 1 );
                red: 100%
                green: 50%
                blue: 0%

          else:
            - light.addressable_set:
                id: encoder_light_ring
                range_from: 0
                range_to: 9
                red: 0%
                green: 0%
                blue: 0%


  - platform: monochromatic
    id: cc_led_05
    name: '${my_name} 5'
    default_transition_length: ${my_default_transition}
    output: pwm_out_05
    gamma_correct: ${my_gamma_correct}

    on_turn_off:
      - light.addressable_set:
          id: encoder_light_ring
          range_from: 0
          range_to: 9
          red: 0%
          green: 0%
          blue: 0%

    on_turn_on:
      - light.addressable_set:
          id: encoder_light_ring
          range_from: 0
          range_to: !lambda |-
            return( ( ( id(cc_led_01).remote_values.get_brightness()) + (id(cc_led_01).remote_values.get_brightness()) + (id(cc_led_01).remote_values.get_brightness()) + (id(cc_led_01).remote_values.get_brightness()) + (id(cc_led_01).remote_values.get_brightness()) + (id(cc_led_01).remote_values.get_brightness()) + (id(cc_led_01).remote_values.get_brightness()) + (id(cc_led_01).remote_values.get_brightness() ) ) / 8 * 10 - 1 );
          red: 100%
          green: 50%
          blue: 0%

    on_state:
      - if:
          condition:
            light.is_on: cc_led_05
          then:
            - light.addressable_set:
                id: encoder_light_ring
                range_from: 0
                range_to: !lambda |-
                    return( ( ( id(cc_led_01).remote_values.get_brightness()) + (id(cc_led_01).remote_values.get_brightness()) + (id(cc_led_01).remote_values.get_brightness()) + (id(cc_led_01).remote_values.get_brightness()) + (id(cc_led_01).remote_values.get_brightness()) + (id(cc_led_01).remote_values.get_brightness()) + (id(cc_led_01).remote_values.get_brightness()) + (id(cc_led_01).remote_values.get_brightness() ) ) / 8 * 10 - 1 );
                red: 100%
                green: 50%
                blue: 0%

          else:
            - light.addressable_set:
                id: encoder_light_ring
                range_from: 0
                range_to: 9
                red: 0%
                green: 0%
                blue: 0%

  - platform: monochromatic
    id: cc_led_06
    name: '${my_name} 6'
    default_transition_length: ${my_default_transition}
    output: pwm_out_06
    gamma_correct: ${my_gamma_correct}
    on_turn_off:
      - light.addressable_set:
          id: encoder_light_ring
          range_from: 0
          range_to: 9
          red: 0%
          green: 0%
          blue: 0%

    on_turn_on:
      - light.addressable_set:
          id: encoder_light_ring
          range_from: 0
          range_to: !lambda |-
            return( ( ( id(cc_led_01).remote_values.get_brightness()) + (id(cc_led_01).remote_values.get_brightness()) + (id(cc_led_01).remote_values.get_brightness()) + (id(cc_led_01).remote_values.get_brightness()) + (id(cc_led_01).remote_values.get_brightness()) + (id(cc_led_01).remote_values.get_brightness()) + (id(cc_led_01).remote_values.get_brightness()) + (id(cc_led_01).remote_values.get_brightness() ) ) / 8 * 10 - 1 );
          red: 100%
          green: 50%
          blue: 0%

    on_state:
      - if:
          condition:
            light.is_on: cc_led_06
          then:
            - light.addressable_set:
                id: encoder_light_ring
                range_from: 0
                range_to: !lambda |-
                    return( ( ( id(cc_led_01).remote_values.get_brightness()) + (id(cc_led_01).remote_values.get_brightness()) + (id(cc_led_01).remote_values.get_brightness()) + (id(cc_led_01).remote_values.get_brightness()) + (id(cc_led_01).remote_values.get_brightness()) + (id(cc_led_01).remote_values.get_brightness()) + (id(cc_led_01).remote_values.get_brightness()) + (id(cc_led_01).remote_values.get_brightness() ) ) / 8 * 10 - 1 );
                red: 100%
                green: 50%
                blue: 0%

          else:
            - light.addressable_set:
                id: encoder_light_ring
                range_from: 0
                range_to: 9
                red: 0%
                green: 0%
                blue: 0%


  - platform: monochromatic
    id: cc_led_07
    name: '${my_name} 7'
    default_transition_length: ${my_default_transition}
    output: pwm_out_07
    gamma_correct: ${my_gamma_correct}
    on_turn_off:
      - light.addressable_set:
          id: encoder_light_ring
          range_from: 0
          range_to: 9
          red: 0%
          green: 0%
          blue: 0%

    on_turn_on:
      - light.addressable_set:
          id: encoder_light_ring
          range_from: 0
          range_to: !lambda |-
            return( ( ( id(cc_led_01).remote_values.get_brightness()) + (id(cc_led_01).remote_values.get_brightness()) + (id(cc_led_01).remote_values.get_brightness()) + (id(cc_led_01).remote_values.get_brightness()) + (id(cc_led_01).remote_values.get_brightness()) + (id(cc_led_01).remote_values.get_brightness()) + (id(cc_led_01).remote_values.get_brightness()) + (id(cc_led_01).remote_values.get_brightness() ) ) / 8 * 10 - 1 );
          red: 100%
          green: 50%
          blue: 0%

    on_state:
      - if:
          condition:
            light.is_on: cc_led_07
          then:
            - light.addressable_set:
                id: encoder_light_ring
                range_from: 0
                range_to: !lambda |-
                    return( ( ( id(cc_led_01).remote_values.get_brightness()) + (id(cc_led_01).remote_values.get_brightness()) + (id(cc_led_01).remote_values.get_brightness()) + (id(cc_led_01).remote_values.get_brightness()) + (id(cc_led_01).remote_values.get_brightness()) + (id(cc_led_01).remote_values.get_brightness()) + (id(cc_led_01).remote_values.get_brightness()) + (id(cc_led_01).remote_values.get_brightness() ) ) / 8 * 10 - 1 );
                red: 100%
                green: 50%
                blue: 0%

          else:
            - light.addressable_set:
                id: encoder_light_ring
                range_from: 0
                range_to: 9
                red: 0%
                green: 0%
                blue: 0%


  - platform: monochromatic
    id: cc_led_08
    name: '${my_name} 8'
    default_transition_length: ${my_default_transition}
    output: pwm_out_08
    gamma_correct: ${my_gamma_correct}
    on_turn_off:
      - light.addressable_set:
          id: encoder_light_ring
          range_from: 0
          range_to: 9
          red: 0%
          green: 0%
          blue: 0%

    on_turn_on:
      - light.addressable_set:
          id: encoder_light_ring
          range_from: 0
          range_to: !lambda |-
            return( ( ( id(cc_led_01).remote_values.get_brightness()) + (id(cc_led_01).remote_values.get_brightness()) + (id(cc_led_01).remote_values.get_brightness()) + (id(cc_led_01).remote_values.get_brightness()) + (id(cc_led_01).remote_values.get_brightness()) + (id(cc_led_01).remote_values.get_brightness()) + (id(cc_led_01).remote_values.get_brightness()) + (id(cc_led_01).remote_values.get_brightness() ) ) / 8 * 10 - 1 );
          red: 100%
          green: 50%
          blue: 0%

    on_state:
      - if:
          condition:
            light.is_on: cc_led_08
          then:
            - light.addressable_set:
                id: encoder_light_ring
                range_from: 0
                range_to: !lambda |-
                    return( ( ( id(cc_led_01).remote_values.get_brightness()) + (id(cc_led_01).remote_values.get_brightness()) + (id(cc_led_01).remote_values.get_brightness()) + (id(cc_led_01).remote_values.get_brightness()) + (id(cc_led_01).remote_values.get_brightness()) + (id(cc_led_01).remote_values.get_brightness()) + (id(cc_led_01).remote_values.get_brightness()) + (id(cc_led_01).remote_values.get_brightness() ) ) / 8 * 10 - 1 );
                red: 100%
                green: 50%
                blue: 0%

          else:
            - light.addressable_set:
                id: encoder_light_ring
                range_from: 0
                range_to: 9
                red: 0%
                green: 0%
                blue: 0%

  - platform: fastled_clockless
    name: '${my_name} encoder light ring'
    id: encoder_light_ring
    chipset: WS2811
    pin: GPIO13
    num_leds: 10
    rgb_order: BRG
    default_transition_length: ${my_default_transition}

    effects:
      - addressable_rainbow:
          name: Rainbow
          speed: 10
          width: 10

switch:
  # virtual switch for night light
  - platform: template
    name: '${my_name} night light'
    id: night_light
    icon: 'mdi:weather-night'
    optimistic: true
    restore_state: true
    on_turn_on:
      - script.execute: motion_light_sequence
    on_turn_off:
      - script.stop: motion_light_sequence
      - light.turn_off: cc_led_01
      - light.turn_off: cc_led_02
      - light.turn_off: cc_led_03
      - light.turn_off: cc_led_04
      - light.turn_off: cc_led_05
      - light.turn_off: cc_led_06
      - light.turn_off: cc_led_07
      - light.turn_off: cc_led_08

  # virtual switch for auto night light
  - platform: template
    name: '${my_name} auto night light'
    id: auto_night_light
    icon: 'mdi:brightness-auto'
    optimistic: true
    restore_state: true
    on_turn_on:
      - if:
          condition:
            - sun.is_below_horizon:
          then:
            switch.turn_on: night_light
    on_turn_off:
      - if:
          condition:
            - sun.is_above_horizon:
          then:
            switch.turn_off: night_light

  - !include common/switches/restart.yaml

dallas:
  - pin: GPIO04
    update_interval: 72s # reads out 50/hour, 1200/day

sensor:
  - platform: template
    id: prev_onboard_temperature
    internal: true

  - platform: template
    id: delta_onboard_temperature

  - platform: dallas
    index: 0
    name: '${my_name} onboard temp.'
    id: onboard_temperature
    # when new value is stated, wait 2sec then publish in prev_onboard_temperature
    on_value:
      then:
        - delay: 2s
        - sensor.template.publish:
            id: prev_onboard_temperature
            state: !lambda return id(onboard_temperature).state;
        # wait 2sec then publish now temp minus previous temp as delta temp
        - delay: 2s
        - sensor.template.publish:
            id: delta_onboard_temperature
            state: !lambda return (id(onboard_temperature).state) - (id(prev_onboard_temperature).state);
        # might add a notification if delta_onboard_temperature is bigger than 3°C

  # rotation only affects brighness when light is on. *No* turning on or off the light.
  - platform: rotary_encoder
    id: dial_encoder
    internal: true
    pin_a: 
      number: GPIO26
      mode: 
        input: true
        pullup: false
    pin_b: 
      number: GPIO27
      mode: 
        input: true
        pullup: false
    resolution: 1

    # increasing brightness
    on_clockwise:
      - if:
          condition:
            light.is_on: cc_led_01
          then:
            - light.dim_relative:
                id: cc_led_01
                relative_brightness: 2%
                transition_length: 250ms

      - if:
          condition:
            light.is_on: cc_led_02
          then:
            - light.dim_relative:
                id: cc_led_02
                relative_brightness: 2%
                transition_length: 250ms

      - if:
          condition:
            light.is_on: cc_led_03
          then:
            - light.dim_relative:
                id: cc_led_03
                relative_brightness: 2%
                transition_length: 250ms

      - if:
          condition:
            light.is_on: cc_led_04
          then:
            - light.dim_relative:
                id: cc_led_04
                relative_brightness: 2%
                transition_length: 250ms

      - if:
          condition:
            light.is_on: cc_led_05
          then:
            - light.dim_relative:
                id: cc_led_05
                relative_brightness: 2%
                transition_length: 250ms

      - if:
          condition:
            light.is_on: cc_led_06
          then:
            - light.dim_relative:
                id: cc_led_06
                relative_brightness: 2%
                transition_length: 250ms

      - if:
          condition:
            light.is_on: cc_led_07
          then:
            - light.dim_relative:
                id: cc_led_07
                relative_brightness: 2%
                transition_length: 250ms

      - if:
          condition:
            light.is_on: cc_led_08
          then:
            - light.dim_relative:
                id: cc_led_08
                relative_brightness: 2%
                transition_length: 250ms

    # lowering brighness
    # stay within visible brighness range, fade down to lowest visible light at max (~10 %).
    on_anticlockwise:
      - if:
          condition:
            # remote values instantly reflects the new brightness, whereas current_values is the transitioning value
            # bigger or equal to min brightness + 0.01 to avoid floating point issue
            lambda: 'return id(cc_led_01).remote_values.get_brightness() >= 0.11;'
          then:
            - light.dim_relative:
                id: cc_led_01
                relative_brightness: -2%
                transition_length: 250ms

      - if:
          condition:
            lambda: 'return id(cc_led_02).remote_values.get_brightness() >= 0.11;'
          then:
            - light.dim_relative:
                id: cc_led_02
                relative_brightness: -2%
                transition_length: 250ms

      - if:
          condition:
            lambda: 'return id(cc_led_03).remote_values.get_brightness() >= 0.11;'
          then:
            - light.dim_relative:
                id: cc_led_03
                relative_brightness: -2%
                transition_length: 250ms

      - if:
          condition:
            lambda: 'return id(cc_led_04).remote_values.get_brightness() >= 0.11;'
          then:
            - light.dim_relative:
                id: cc_led_04
                relative_brightness: -2%
                transition_length: 250ms

      - if:
          condition:
            lambda: 'return id(cc_led_05).remote_values.get_brightness() >= 0.11;'
          then:
            - light.dim_relative:
                id: cc_led_05
                relative_brightness: -2%
                transition_length: 250ms

      - if:
          condition:
            lambda: 'return id(cc_led_06).remote_values.get_brightness() >= 0.11;'
          then:
            - light.dim_relative:
                id: cc_led_06
                relative_brightness: -2%
                transition_length: 250ms

      - if:
          condition:
            lambda: 'return id(cc_led_07).remote_values.get_brightness() >= 0.11;'
          then:
            - light.dim_relative:
                id: cc_led_07
                relative_brightness: -2%
                transition_length: 250ms

      - if:
          condition:
            lambda: 'return id(cc_led_08).remote_values.get_brightness() >= 0.11;'
          then:
            - light.dim_relative:
                id: cc_led_08
                relative_brightness: -2%
                transition_length: 250ms

  - !include common/sensors/uptime.yaml
  - !include common/sensors/wifi_signal.yaml
  - !include common/sensors/wifi_signal_percents.yaml

text_sensor:
  - !include common/text_sensors/wifi_info.yaml
  - !include common/text_sensors/mac.yaml
  - !include common/text_sensors/version.yaml

binary_sensor:
  # define the momentary switch and it's action
  - platform: gpio
    name: '${my_name} switch'
    pin:
      number: GPIO05
      mode: 
        input: true
        pullup: false
    filters:
      - invert:
    disabled_by_default: true
    on_multi_click:
      - timing:
          - ON for at most 1s
          - OFF for at least 0.2s
        then:
          - light.toggle: cc_led_01
          - light.toggle: cc_led_02
          - light.toggle: cc_led_03
          - light.toggle: cc_led_04
          - light.toggle: cc_led_05
          - light.toggle: cc_led_06
          - light.toggle: cc_led_07
          - light.toggle: cc_led_08

      - timing:
          - ON for at least 4s
        then:
          - switch.toggle: auto_night_light

  - platform: gpio
    device_class: motion
    name: '${my_name} motion'
    id: motion
    pin:
      number: GPIO32
      mode: 
        input: true
        pullup: false
    filters:
      - invert:
    # do night light sequence on motion detection only if switch night light is on
    on_press:
      if:
        condition:
          switch.is_on: night_light
        then:
          script.execute: motion_light_sequence

  - !include common/binary_sensors/status.yaml

sun:
  latitude: ${my_latitude}
  longitude: ${my_longitude}
  on_sunset:
      if:
        condition:
          switch.is_on: auto_night_light
        then:
          - switch.turn_on: night_light
  on_sunrise:
      if:
        condition:
          switch.is_on: auto_night_light
        then:
          - switch.turn_off: night_light

status_led:
  # use blue led on esp for status notifications
  # https://esphome.io/components/status_led.html
  pin:
    number: GPIO2
    mode:
      output: true
