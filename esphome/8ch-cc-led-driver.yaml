---
#########################################
# 8 channel led driver constant current #
#########################################

# code made for board v0.991, 2021-12-25

# esp board model:  MH-ET LIVE ESP32 MiniKit

# Pinout reference
# ================
# ---------------------------------------
# | GPIO | Board | Usage                |
# |------|-------|----------------------|
# | 04   | U20   | dallas temp. sensor  |
# |------|-------|----------------------|
# | 05   | J130  | momentary switch     |
# |------|-------|----------------------|
# | 13   | J110	 | free to use GPIO     |
# |------|-------|----------------------|
# | 16   | LED1	 | LED1 dimming (pwm)   |
# |------|-------|----------------------|
# | 17   | LED2	 | LED2 dimming (pwm)   |
# |------|-------|----------------------|
# | 18   | LED3	 | LED3 dimming (pwm)   |
# |------|-------|----------------------|
# | 19   | LED4	 | LED4 dimming (pwm)   |
# |------|-------|----------------------|
# | 21   | LED5  | LED5 dimming (pwm)   |
# |------|-------|----------------------|
# | 22   | LED6	 | LED6 dimming (pwm)   |
# |------|-------|----------------------|
# | 23   | LED7  | LED7 dimming (pwm)   |
# |------|-------|----------------------|
# | 25   | LED8  | LED8 dimming (pwm)   |
# |------|-------|----------------------|
# | 26   | J130  | rotary encoder pin A |
# |------|-------|----------------------|
# | 27   | J130  | rotary encoder pin B |
# |------|-------|----------------------|
# | 32   | J120  | motion sensor (pir)  |
# |------|-------|----------------------|
# | 33   | J110  | free to use GPIO     |
# ---------------------------------------

##### basic configs #####

# set up variables
substitutions:
  my_name: 'Downlight'
  my_reboot_timeout: '30min'
  my_static_ip: '10.11.12.13' # use one that fits in your network
  my_pwm_frequency: '19531Hz'
  my_default_transition: '2.5s'
  my_gamma_correct: '2.5'

# define core configs
esphome:
  name: downlight-group-1
  comment: ${my_name}
  platform: ESP32
  board: mhetesp32minikit

# import basic settings
# <<: !include common/wifi.yaml
wifi:
  ssid: 'your WiFi networ name' # !secret wifi_ssid
  password: 'your super secure WiFi passphrase' # !secret wifi_password

  fast_connect: false # only one access point broadcasting the SSID => true, else false
  reboot_timeout: ${my_reboot_timeout}
  manual_ip:
    static_ip: ${my_static_ip}
    gateway: 10.11.12.1 # ip address of the gateway router in your network
    subnet: 255.255.255.0
    dns1: 10.11.12.1 # ip address of the gateway router in your network
    dns2: 1.1.1.1
  ap:
    # after connecting to it, navigate to http://192.168.4.1/
    ssid: '${my_name} AP'
    password: 'passphrase for the esp WiFi' # !secret ap_wifi_password
    ap_timeout: 1min
    # channel: 8

captive_portal:

# <<: !include common/api.yaml
api:
  reboot_timeout: ${my_reboot_timeout}
  password: 'your super secret api pasword' # !secret native_api_password

# <<: !include common/ota.yaml
ota:
  safe_mode: true
  password: 'your super secret ota password' # !secret ota_password


# <<: !include common/time.yaml
time:
  - platform: homeassistant
    id: homeassistant_time
    on_time:
        # device restart (5 minutes after scheduled dhcp router and WiFi APs reboot)
      - days_of_week: SUN
        hours: 4
        minutes: 35
        seconds: 0
        then:
          - switch.toggle: reboot

# <<: !include common/logger.yaml
logger:
  level: DEBUG
  # disable logging to serial
  baud_rate: 0

# <<: !include common/web_server.yaml
web_server:
  port: 80
  auth:
    username: 'your secret web interface user name' # !secret web_srv_user
    password: 'your secret web interface password' # !secret web_srv_pswd


dallas:
  - pin: GPIO04
    update_interval: 72s # reads out 50/hour, 1200/day

##### start specific configs #####

script:
  # react on motion detection during night times
  # turn on lights at mid to high brightness with 10sec transistion time
  # stay like this for some time
  # then fade down lights to low brightness with 30sec transistion time
  - id: motion_light_sequence
    mode: restart
    then:
      - lambda: |-
          auto call = id(downlight_01).turn_on ();
          call.set_transition_length (10000);
          call.set_brightness (0.66);
          call.perform ();

      - lambda: |-
          auto call = id(downlight_02).turn_on ();
          call.set_transition_length (10000);
          call.set_brightness (0.66);
          call.perform ();

      - lambda: |-
          auto call = id(downlight_03).turn_on ();
          call.set_transition_length (10000);
          call.set_brightness (0.66);
          call.perform ();

      - lambda: |-
          auto call = id(downlight_04).turn_on ();
          call.set_transition_length (10000);
          call.set_brightness (0.66);
          call.perform ();

      - lambda: |-
          auto call = id(downlight_05).turn_on ();
          call.set_transition_length (10000);
          call.set_brightness (0.66);
          call.perform ();

      - lambda: |-
          auto call = id(downlight_06).turn_on ();
          call.set_transition_length (10000);
          call.set_brightness (0.66);
          call.perform ();

      - lambda: |-
          auto call = id(downlight_07).turn_on ();
          call.set_transition_length (10000);
          call.set_brightness (0.66);
          call.perform ();

      - lambda: |-
          auto call = id(downlight_08).turn_on ();
          call.set_transition_length (10000);
          call.set_brightness (0.66);
          call.perform ();

      # stay at this level for some time
      - delay: 150sec

      # fade lights down slowly to low brightness
      - lambda: |-
          auto call = id(downlight_01).make_call ();
          call.set_transition_length (30000);
          call.set_brightness (0.1);
          call.perform ();
      - lambda: |-
          auto call = id(downlight_02).make_call ();
          call.set_transition_length (30000);
          call.set_brightness (0.1);
          call.perform ();
      - lambda: |-
          auto call = id(downlight_03).make_call ();
          call.set_transition_length (30000);
          call.set_brightness (0.1);
          call.perform ();
      - lambda: |-
          auto call = id(downlight_04).make_call ();
          call.set_transition_length (30000);
          call.set_brightness (0.1);
          call.perform ();
      - lambda: |-
          auto call = id(downlight_05).make_call ();
          call.set_transition_length (30000);
          call.set_brightness (0.1);
          call.perform ();
      - lambda: |-
          auto call = id(downlight_06).make_call ();
          call.set_transition_length (30000);
          call.set_brightness (0.1);
          call.perform ();
      - lambda: |-
          auto call = id(downlight_07).make_call ();
          call.set_transition_length (30000);
          call.set_brightness (0.1);
          call.perform ();
      - lambda: |-
          auto call = id(downlight_08).make_call ();
          call.set_transition_length (30000);
          call.set_brightness (0.1);
          call.perform ();

output:
  - platform: ledc
    pin: GPIO16
    frequency: ${my_pwm_frequency}
    id: pwm_out_01
    max_power: '75%' # lowering power to protect newly connected led lights

  - platform: ledc
    pin: GPIO17
    frequency: ${my_pwm_frequency}
    id: pwm_out_02
    max_power: '75%' # lowering power to protect newly connected led lights

  - platform: ledc
    pin: GPIO18
    frequency: ${my_pwm_frequency}
    id: pwm_out_03
    max_power: '75%' # lowering power to protect newly connected led lights

  - platform: ledc
    pin: GPIO19
    frequency: ${my_pwm_frequency}
    id: pwm_out_04
    max_power: '100%' # downlight white, Iled max 290mA, Vled 15.4V

  - platform: ledc
    pin: GPIO21
    frequency: ${my_pwm_frequency}
    id: pwm_out_05
    max_power: '87%' # wall light gold/black, Iled max 250mA, Vled 18V

  - platform: ledc
    pin: GPIO22
    frequency: ${my_pwm_frequency}
    id: pwm_out_06
    max_power: '75%' # lowering power to protect newly connected led lights

  - platform: ledc
    pin: GPIO23
    frequency: ${my_pwm_frequency}
    id: pwm_out_07
    max_power: '75%' # lowering power to protect newly connected led lights

  - platform: ledc
    pin: GPIO25
    frequency: ${my_pwm_frequency}
    id: pwm_out_08
    max_power: '75%' # lowering power to protect newly connected led lights

light:
  - platform: monochromatic
    id: downlight_01
    name: '${my_name} 1'
    default_transition_length: ${my_default_transition}
    output: pwm_out_01
    gamma_correct: ${my_gamma_correct}
    effects:
      - lambda:
          name: 'Fader 15-100% 20sec'
          update_interval: 20000ms
          lambda: |-
            static int state = 0;
            auto call = id(downlight_01).turn_on();
            call.set_transition_length(20000);
            call.set_brightness(0.15 + (state * 0.85));
            call.perform();
            state = 1 - state;

      - lambda:
          name: 'Fader 15-50% 20sec'
          update_interval: 20000ms
          lambda: |-
            static int state = 0;
            auto call = id(downlight_01).turn_on();
            call.set_transition_length(20000);
            call.set_brightness(0.15 + (state * 0.35));
            call.perform();
            state = 1 - state;

      - lambda:
          name: 'Fader 40-90% 20sec'
          update_interval: 20000ms
          lambda: |-
            static int state = 0;
            auto call = id(downlight_01).turn_on();
            call.set_transition_length(20000);
            call.set_brightness(0.4 + (state * 0.5));
            call.perform();
            state = 1 - state;

  - platform: monochromatic
    id: downlight_02
    name: '${my_name} 2'
    default_transition_length: ${my_default_transition}
    output: pwm_out_02
    gamma_correct: ${my_gamma_correct}
    effects:
      - lambda:
          name: 'Fader 15-100% 20sec'
          update_interval: 20000ms
          lambda: |-
            static int state = 0;
            auto call = id(downlight_02).turn_on();
            call.set_transition_length(20000);
            call.set_brightness(0.15 + (state * 0.85));
            call.perform();
            state = 1 - state;

      - lambda:
          name: 'Fader 15-50% 20sec'
          update_interval: 20000ms
          lambda: |-
            static int state = 0;
            auto call = id(downlight_02).turn_on();
            call.set_transition_length(20000);
            call.set_brightness(0.15 + (state * 0.35));
            call.perform();
            state = 1 - state;

      - lambda:
          name: 'Fader 40-90% 20sec'
          update_interval: 20000ms
          lambda: |-
            static int state = 0;
            auto call = id(downlight_02).turn_on();
            call.set_transition_length(20000);
            call.set_brightness(0.4 + (state * 0.5));
            call.perform();
            state = 1 - state;

  - platform: monochromatic
    id: downlight_03
    name: '${my_name} 3'
    default_transition_length: ${my_default_transition}
    output: pwm_out_03
    gamma_correct: ${my_gamma_correct}
    effects:
      - lambda:
          name: 'Fader 15-100% 20sec'
          update_interval: 20000ms
          lambda: |-
            static int state = 0;
            auto call = id(downlight_03).turn_on();
            call.set_transition_length(20000);
            call.set_brightness(0.15 + (state * 0.85));
            call.perform();
            state = 1 - state;

      - lambda:
          name: 'Fader 15-50% 20sec'
          update_interval: 20000ms
          lambda: |-
            static int state = 0;
            auto call = id(downlight_03).turn_on();
            call.set_transition_length(20000);
            call.set_brightness(0.15 + (state * 0.35));
            call.perform();
            state = 1 - state;

      - lambda:
          name: 'Fader 40-90% 20sec'
          update_interval: 20000ms
          lambda: |-
            static int state = 0;
            auto call = id(downlight_03).turn_on();
            call.set_transition_length(20000);
            call.set_brightness(0.4 + (state * 0.5));
            call.perform();
            state = 1 - state;

  - platform: monochromatic
    id: downlight_04
    name: '${my_name} 4'
    default_transition_length: ${my_default_transition}
    output: pwm_out_04
    gamma_correct: ${my_gamma_correct}
    effects:
      - lambda:
          name: 'Fader 15-100% 20sec'
          update_interval: 20000ms
          lambda: |-
            static int state = 0;
            auto call = id(downlight_04).turn_on();
            call.set_transition_length(20000);
            call.set_brightness(0.15 + (state * 0.85));
            call.perform();
            state = 1 - state;

      - lambda:
          name: 'Fader 15-50% 20sec'
          update_interval: 20000ms
          lambda: |-
            static int state = 0;
            auto call = id(downlight_04).turn_on();
            call.set_transition_length(20000);
            call.set_brightness(0.15 + (state * 0.35));
            call.perform();
            state = 1 - state;

      - lambda:
          name: 'Fader 40-90% 20sec'
          update_interval: 20000ms
          lambda: |-
            static int state = 0;
            auto call = id(downlight_04).turn_on();
            call.set_transition_length(20000);
            call.set_brightness(0.4 + (state * 0.5));
            call.perform();
            state = 1 - state;

  - platform: monochromatic
    id: downlight_05
    name: '${my_name} 5'
    default_transition_length: ${my_default_transition}
    output: pwm_out_05
    gamma_correct: ${my_gamma_correct}
    effects:
      - lambda:
          name: 'Fader 15-100% 20sec'
          update_interval: 20000ms
          lambda: |-
            static int state = 0;
            auto call = id(downlight_05).turn_on();
            call.set_transition_length(20000);
            call.set_brightness(0.15 + (state * 0.85));
            call.perform();
            state = 1 - state;

      - lambda:
          name: 'Fader 15-50% 20sec'
          update_interval: 20000ms
          lambda: |-
            static int state = 0;
            auto call = id(downlight_05).turn_on();
            call.set_transition_length(20000);
            call.set_brightness(0.15 + (state * 0.35));
            call.perform();
            state = 1 - state;

      - lambda:
          name: 'Fader 40-90% 20sec'
          update_interval: 20000ms
          lambda: |-
            static int state = 0;
            auto call = id(downlight_05).turn_on();
            call.set_transition_length(20000);
            call.set_brightness(0.4 + (state * 0.5));
            call.perform();
            state = 1 - state;

  - platform: monochromatic
    id: downlight_06
    name: '${my_name} 6'
    default_transition_length: ${my_default_transition}
    output: pwm_out_06
    gamma_correct: ${my_gamma_correct}
    effects:
      - lambda:
          name: 'Fader 15-100% 20sec'
          update_interval: 20000ms
          lambda: |-
            static int state = 0;
            auto call = id(downlight_06).turn_on();
            call.set_transition_length(20000);
            call.set_brightness(0.15 + (state * 0.85));
            call.perform();
            state = 1 - state;

      - lambda:
          name: 'Fader 15-50% 20sec'
          update_interval: 20000ms
          lambda: |-
            static int state = 0;
            auto call = id(downlight_06).turn_on();
            call.set_transition_length(20000);
            call.set_brightness(0.15 + (state * 0.35));
            call.perform();
            state = 1 - state;

      - lambda:
          name: 'Fader 40-90% 20sec'
          update_interval: 20000ms
          lambda: |-
            static int state = 0;
            auto call = id(downlight_06).turn_on();
            call.set_transition_length(20000);
            call.set_brightness(0.4 + (state * 0.5));
            call.perform();
            state = 1 - state;

  - platform: monochromatic
    id: downlight_07
    name: '${my_name} 7'
    default_transition_length: ${my_default_transition}
    output: pwm_out_07
    gamma_correct: ${my_gamma_correct}

    effects:
      - lambda:
          name: 'Fader 15-100% 20sec'
          update_interval: 20000ms
          lambda: |-
            static int state = 0;
            auto call = id(downlight_07).turn_on();
            call.set_transition_length(20000);
            call.set_brightness(0.15 + (state * 0.85));
            call.perform();
            state = 1 - state;

      - lambda:
          name: 'Fader 15-50% 20sec'
          update_interval: 20000ms
          lambda: |-
            static int state = 0;
            auto call = id(downlight_07).turn_on();
            call.set_transition_length(20000);
            call.set_brightness(0.15 + (state * 0.35));
            call.perform();
            state = 1 - state;

      - lambda:
          name: 'Fader 40-90% 20sec'
          update_interval: 20000ms
          lambda: |-
            static int state = 0;
            auto call = id(downlight_07).turn_on();
            call.set_transition_length(20000);
            call.set_brightness(0.4 + (state * 0.5));
            call.perform();
            state = 1 - state;

  - platform: monochromatic
    id: downlight_08
    name: '${my_name} 8'
    default_transition_length: ${my_default_transition}
    output: pwm_out_08
    gamma_correct: ${my_gamma_correct}

    effects:
      - lambda:
          name: 'Fader 15-100% 20sec'
          update_interval: 20000ms
          lambda: |-
            static int state = 0;
            auto call = id(downlight_08).turn_on();
            call.set_transition_length(20000);
            call.set_brightness(0.15 + (state * 0.85));
            call.perform();
            state = 1 - state;

      - lambda:
          name: 'Fader 15-50% 20sec'
          update_interval: 20000ms
          lambda: |-
            static int state = 0;
            auto call = id(downlight_08).turn_on();
            call.set_transition_length(20000);
            call.set_brightness(0.15 + (state * 0.35));
            call.perform();
            state = 1 - state;

      - lambda:
          name: 'Fader 40-90% 20sec'
          update_interval: 20000ms
          lambda: |-
            static int state = 0;
            auto call = id(downlight_08).turn_on();
            call.set_transition_length(20000);
            call.set_brightness(0.4 + (state * 0.5));
            call.perform();
            state = 1 - state;

switch:
  # virtual switch for night light
  - platform: template
    name: '${my_name} night light'
    id: night_light
    icon: 'mdi:weather-night'
    optimistic: true
    restore_state: true
    on_turn_on:
      - script.execute: motion_light_sequence

    on_turn_off:
      - script.stop: ${my_device}_motion_light_sequence
      - light.turn_off: downlight_01
      - light.turn_off: downlight_02
      - light.turn_off: downlight_03
      - light.turn_off: downlight_04
      - light.turn_off: downlight_05
      - light.turn_off: downlight_06
      - light.turn_off: downlight_07
      - light.turn_off: downlight_08

  # virtual switch for auto night light
  - platform: template
    name: '${my_name} auto night light'
    id: auto_night_light
    icon: 'mdi:brightness-auto'
    optimistic: true
    restore_state: true
    on_turn_on:
      - if:
          condition:
            - sun.is_below_horizon:
          then:
            switch.turn_on: night_light
            
    on_turn_off:
      - if:
          condition:
            - sun.is_above_horizon:
          then:
            switch.turn_off: night_light

  # - !include common/switches/restart.yaml
  - platform: restart
    name: '${my_name} reboot'
    id: reboot
    icon: mdi:restart

sensor:
  - platform: dallas
    index: 0
    name: '${my_name} temperature'
    id: onboard_temperature
    # when new value is stated, wait 2sec then publish in prev_onboard_temperature
    on_value:
      then:
        - delay: 2s
        - sensor.template.publish:
            id: prev_onboard_temperature
            state: !lambda return id(onboard_temperature).state;
        # wait 2sec then publish now temp minus previous temp
        - delay: 2s
        - sensor.template.publish:
            id: delta_onboard_temperature
            state: !lambda return (id(onboard_temperature).state) - (id(prev_onboard_temperature).state);
        # might add a notification if delta_onboard_temperature is bigger than 3°C in 144sec

  - platform: template
    id: prev_onboard_temperature
    internal: true

  - platform: template
    id: delta_onboard_temperature

  # rotation only affects brighness when light is on. *No* turning on or off the light
  # stay within visible brighness range, dimm down to lowest visible light at max (somewhere between 5 to 10 %)
  - platform: rotary_encoder
    id: dial_encoder
    internal: true
    pin_a: 
      number: GPIO26
      mode: INPUT
    pin_b: 
      number: GPIO27
      mode: INPUT
    resolution: 1

    # increasing brightness
    on_clockwise:
      - if:
          condition:
            light.is_on: downlight_01
          then:
            - light.dim_relative:
                id: downlight_01
                relative_brightness: 2%
                transition_length: 250ms

      - if:
          condition:
            light.is_on: downlight_02
          then:
            - light.dim_relative:
                id: downlight_02
                relative_brightness: 2%
                transition_length: 250ms

      - if:
          condition:
            light.is_on: downlight_03
          then:
            - light.dim_relative:
                id: downlight_03
                relative_brightness: 2%
                transition_length: 250ms

      - if:
          condition:
            light.is_on: downlight_04
          then:
            - light.dim_relative:
                id: downlight_04
                relative_brightness: 2%
                transition_length: 250ms

      - if:
          condition:
            light.is_on: downlight_05
          then:
            - light.dim_relative:
                id: downlight_05
                relative_brightness: 2%
                transition_length: 250ms

      - if:
          condition:
            light.is_on: downlight_06
          then:
            - light.dim_relative:
                id: downlight_06
                relative_brightness: 2%
                transition_length: 250ms

      - if:
          condition:
            light.is_on: downlight_07
          then:
            - light.dim_relative:
                id: downlight_07
                relative_brightness: 2%
                transition_length: 250ms

      - if:
          condition:
            light.is_on: downlight_08
          then:
            - light.dim_relative:
                id: downlight_08
                relative_brightness: 2%
                transition_length: 250ms

    # lowering brighness
    on_anticlockwise:
      - if:
          condition:
            # remote values instantly reflects the new brightness, whereas current_values is the transitioning value
            # bigger or equal to min brightness + 0.01 to avoid floating point issue
            lambda: 'return id(downlight_01).remote_values.get_brightness() >= 0.11;'
          then:
            - light.dim_relative:
                id: downlight_01
                relative_brightness: -2%
                transition_length: 250ms

      - if:
          condition:
            # remote values instantly reflects the new brightness, whereas current_values is the transitioning value
            # bigger or equal to min brightness + 0.01 to avoid floating point issue
            lambda: 'return id(downlight_02).remote_values.get_brightness() >= 0.11;'
          then:
            - light.dim_relative:
                id: downlight_02
                relative_brightness: -2%
                transition_length: 250ms

      - if:
          condition:
            # remote values instantly reflects the new brightness, whereas current_values is the transitioning value
            # bigger or equal to min brightness + 0.01 to avoid floating point issue
            lambda: 'return id(downlight_03).remote_values.get_brightness() >= 0.11;'
          then:
            - light.dim_relative:
                id: downlight_03
                relative_brightness: -2%
                transition_length: 250ms

      - if:
          condition:
            # remote values instantly reflects the new brightness, whereas current_values is the transitioning value
            # bigger or equal to min brightness + 0.01 to avoid floating point issue
            lambda: 'return id(downlight_04).remote_values.get_brightness() >= 0.11;'
          then:
            - light.dim_relative:
                id: downlight_04
                relative_brightness: -2%
                transition_length: 250ms

      - if:
          condition:
            # remote values instantly reflects the new brightness, whereas current_values is the transitioning value
            # bigger or equal to min brightness + 0.01 to avoid floating point issue
            lambda: 'return id(downlight_05).remote_values.get_brightness() >= 0.11;'
          then:
            - light.dim_relative:
                id: downlight_05
                relative_brightness: -2%
                transition_length: 250ms

      - if:
          condition:
            # remote values instantly reflects the new brightness, whereas current_values is the transitioning value
            # bigger or equal to min brightness + 0.01 to avoid floating point issue
            lambda: 'return id(downlight_06).remote_values.get_brightness() >= 0.11;'
          then:
            - light.dim_relative:
                id: downlight_06
                relative_brightness: -2%
                transition_length: 250ms

      - if:
          condition:
            # remote values instantly reflects the new brightness, whereas current_values is the transitioning value
            # bigger or equal to min brightness + 0.01 to avoid floating point issue
            lambda: 'return id(downlight_07).remote_values.get_brightness() >= 0.11;'
          then:
            - light.dim_relative:
                id: downlight_07
                relative_brightness: -2%
                transition_length: 250ms

      - if:
          condition:
            # remote values instantly reflects the new brightness, whereas current_values is the transitioning value
            # bigger or equal to min brightness + 0.01 to avoid floating point issue
            lambda: 'return id(downlight_08).remote_values.get_brightness() >= 0.11;'
          then:
            - light.dim_relative:
                id: downlight_08
                relative_brightness: -2%
                transition_length: 250ms

  # - !include common/sensors/uptime.yaml
  - platform: uptime
    name: '${my_name} uptime hours'
    id: uptime_hours
    icon : mdi:clock-start
    update_interval: 6min
    accuracy_decimals: 1
    unit_of_measurement: h
    filters:
      # delete not a number or calculate and state value
      - lambda: 'if (isnan(x)) return{}; else return(x/3600);'

  # - !include common/sensors/wifi_signal.yaml
  # # WiFi rssi in dBs
  - platform: wifi_signal
    id: wifi_rssi_dbs
    internal: true
    update_interval: 6min
    filters:
      # delete not a number or state value
      - lambda: 'if (isnan(x)) return{}; else return(x);'

  # - !include common/sensors/wifi_signal_percents.yaml
  # # WiFi rssi in percents
  - platform: template
    name: '${my_name} WiFi signal'
    id: wifi_rssi
    update_interval: 5min
    unit_of_measurement: '%'
    accuracy_decimals: 0
    icon: mdi:wifi-strength-2
    lambda: |-
      if (id(wifi_rssi_dbs).state < -92.0)
        return 1.0;
      if (id(wifi_rssi_dbs).state > -21.0)
        return 100.0;
      else
        return round(( -0.0154 * id(wifi_rssi_dbs).state * id(wifi_rssi_dbs).state ) - ( 0.3794 * id(wifi_rssi_dbs).state ) + 98.182 );
    filters:
      # delete not a number or state value
      - lambda: 'if (isnan(x)) return{}; else return(x);'
      # do not report changes lower than +-1%
      - delta: 1.0

text_sensor:
  # - !include common/text_sensors/wifi_info.yaml
  - platform: wifi_info
    ip_address:
      name: '${my_name} IP'
      icon: mdi:ip-network-outline
    ssid:
      name: '${my_name} SSID'
      icon: mdi:access-point-network
    bssid:
      name: '${my_name} BSSID'
      icon: mdi:plus-network-outline

  # - !include common/text_sensors/mac.yaml
  - platform: template
    name: '${my_name} MAC'
    icon: mdi:minus-network-outline
    update_interval: 6min
    lambda: |-
      return {WiFi.macAddress().c_str()};

  # - !include common/text_sensors/version.yaml
  - platform: version
    name: '${my_name} ESPHome version'

binary_sensor:
  # define the momentary switch and it's action
  - platform: gpio
    name: '${my_name} light switch'
    id: button_switch
    pin:
      number: GPIO05
      mode: INPUT
      inverted: true
    on_click:
      then:
        - light.toggle: downlight_01
        - light.toggle: downlight_02
        - light.toggle: downlight_03
        - light.toggle: downlight_04
        - light.toggle: downlight_05
        - light.toggle: downlight_06
        - light.toggle: downlight_07
        - light.toggle: downlight_08

  - platform: gpio
    device_class: motion
    name: '${my_name} motion'
    id: motion
    pin:
      number: GPIO32
      mode: INPUT
      inverted: true
    # do night light sequence on motion detection only if switch night light is on
    on_press:
      if:
        condition:
          switch.is_on: night_light
        then:
          script.execute: motion_light_sequence

  # - !include common/binary_sensors/status.yaml
  - platform: status
    name: '${my_name} connection'
    id: connection_status
    on_state:
      if:
        condition:
          binary_sensor.is_on: connection_status
        then:
          - logger.log: '${my_name}: Connection api/mqtt is up.'
        else:
          - logger.log: '${my_name}: Connection api/mqtt is down.'

sun:
  latitude: !secret latitude
  longitude: !secret longitude
  
  on_sunset:
      if:
        condition:
          switch.is_on: auto_night_light
        then:
          - switch.turn_on: night_light
  
  on_sunrise:
      if:
        condition:
          switch.is_on: auto_night_light
        then:
          - light.turn_off: downlight_01
          - light.turn_off: downlight_02
          - light.turn_off: downlight_03
          - light.turn_off: downlight_04
          - light.turn_off: downlight_05
          - light.turn_off: downlight_06
          - light.turn_off: downlight_07
          - light.turn_off: downlight_08

status_led:
  # use blue led on esp for status notifications
  # https://esphome.io/components/status_led.html
  pin:
    number: GPIO2
    inverted: false

